{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Fn.py: enjoy FP in Python\r\n=========================\r\n\r\nDespite the fact that Python is not pure-functional programming\r\nlanguage, it's multi-paradigm PL and it gives you enough freedom to take\r\ncredits from functional programming approach. There are theoretical and\r\npractical advantages to the functional style:\r\n\r\n-  Formal provability\r\n-  Modularity\r\n-  Composability\r\n-  Ease of debugging and testing\r\n\r\n`Fn.py` library provides you with missing \"batteries\" to get maximum\r\nfrom functional approach even in mostly-imperative program.\r\n\r\nMore about functional approach from my Pycon UA 2012 talks: [Functional\r\nProgramming with\r\nPython](http://ua.pycon.org/static/talks/kachayev/).\r\n\r\nScala-style lambdas definition\r\n------------------------------\r\n\r\n```python\r\nfrom fn import _\r\nfrom fn.iters import zipwith\r\nfrom itertools import repeat\r\n\r\nassert list(map(_ * 2, range(5))) == [0,2,4,6,8]\r\nassert list(filter(_ < 10, [9,10,11])) == [9]\r\nassert list(zipwith(_ + _)([0,1,2], repeat(10))) == [10,11,12]\r\n```\r\n\r\nMore examples of using `_` you can find in [test\r\ncases](https://github.com/kachayev/fn.py/blob/master/tests.py)\r\ndeclaration (attributes resolving, method calling, slicing).\r\n\r\n**Attention!** If you work in interactive python shell, your should remember that `_` means \"latest output\" and you'll get unpredictable results. In this case, you can do something like `from fn import _ as __`.\r\n\r\nStreams and infinite sequences declaration\r\n------------------------------------------\r\n\r\nLazy-evaluated scala-style streams. Basic idea: evaluate each new\r\nelement \"on demand\" and share calculated elements between all created\r\niterators. `Stream` object supports `<<` operator that means pushing\r\nnew elements when it's necessary.\r\n\r\nSimplest cases:\r\n\r\n```python\r\nfrom fn import Stream\r\n\r\ns = Stream() << [1,2,3,4,5]\r\nassert list(s) == [1,2,3,4,5]\r\nassert s[1] == 2\r\nassert s[0:2] == [1,2]\r\n\r\ns = Stream() << range(6) << [6,7]\r\nassert list(s) == [0,1,2,3,4,5,6,7]\r\n\r\ndef gen():\r\n    yield 1\r\n    yield 2\r\n    yield 3\r\n\r\ns = Stream() << gen << (4,5)\r\nassert list(s) == [1,2,3,4,5]\r\n```\r\n\r\nLazy-evaluated stream is useful for infinite sequences, i.e. fibonacci\r\nsequence can be calculated as:\r\n\r\n```python\r\nfrom fn import Stream\r\nfrom fn.iters import take, drop, map\r\nfrom operator import add\r\n\r\nf = Stream()\r\nfib = f << [0, 1] << map(add, f, drop(1, f))\r\n\r\nassert list(take(10, fib)) == [0,1,1,2,3,5,8,13,21,34]\r\nassert fib[20] == 6765\r\nassert fib[30:35] == [832040,1346269,2178309,3524578,5702887]\r\n```\r\n\r\nHigh-level operations with functions\r\n------------------------------------\r\n\r\n`fn.F` is a useful function wrapper to provide easy-to-use partial\r\napplication and functions composition.\r\n\r\n```python\r\nfrom fn import F, _\r\nfrom operator import add, mul\r\n\r\n# F(f, *args) means partial application \r\n# same as functools.partial but returns fn.F instance\r\nassert F(add, 1)(10) == 11\r\n\r\n# F << F means functions composition,\r\n# so (F(f) << g)(x) == f(g(x))\r\nf = F(add, 1) << F(mul, 100)\r\nassert list(map(f, [0, 1, 2])) == [1, 101, 201]\r\nassert list(map(F() << str << (_ ** 2) << (_ + 1), range(3))) == [\"1\", \"4\", \"9\"]\r\n```\r\n\r\nYou can find more examples for compositions usage in `fn._`\r\nimplementation [source\r\ncode](https://github.com/kachayev/fn.py/blob/master/fn/underscore.py).\r\n\r\n`fn.op.apply` executes given function with given positional arguments\r\nin list (or any other iterable). `fn.op.flip` returns you function\r\nthat will reverse arguments order before apply.\r\n\r\n```python\r\nfrom fn.op import apply, flip\r\nfrom operator import add, sub\r\n\r\nassert apply(add, [1, 2]) == 3\r\nassert flip(sub)(20,10) == -10\r\nassert list(map(apply, [add, mul], [(1,2), (10,20)])) == [3, 200]\r\n```\r\n\r\nItertools recipes\r\n-----------------\r\n\r\n`fn.iters` module consists from two parts. First one is \"unification\"\r\nof lazy functionality for few functions to work the same way in Python\r\n2+/3+:\r\n\r\n-  `map` (returns `itertools.imap` in Python 2+)\r\n-  `filter` (returns `itertools.ifilter` in Python 2+)\r\n-  `reduce` (returns `functools.reduce` in Python 3+)\r\n-  `zip` (returns `itertools.izip` in Python 2+)\r\n-  `range` (returns `xrange` in Python 2+)\r\n-  `filterfalse` (returns `itertools.ifilterfalse` in Python 2+)\r\n-  `zip_longest` (returns `itertools.izip_longest` in Python 2+)\r\n\r\nSecond part of module is high-level recipes to work with iterators. Most\r\nof them taken from [Python docs](http://docs.python.org/2.7/library/itertools.html#itertools.product)\r\nand adopted to work both with Python 2+/3+. Such recipes as `drop`,\r\n`takelast`, `droplast`, `splitat`, `splitby` I have already\r\nsubmitted as [docs patch](http://bugs.python.org/issue16774) which is\r\nreview status just now.\r\n\r\n-  ``take``, ``drop``\r\n-  ``takelast``, ``droplast``\r\n-  ``head``, ``tail``\r\n-  ``consume``\r\n-  ``nth``\r\n-  ``padnone``, ``ncycles``\r\n-  ``repeatfunc``\r\n-  ``grouper``, ``powerset``, ``pairwise``\r\n-  ``roundrobin``\r\n-  ``partition``, ``splitat``, ``splitby``\r\n-  ``flatten``\r\n-  ``zipwith``\r\n-  ``iter_except``\r\n\r\nMore information about use cases you can find in docstrings for each\r\nfunction in [source\r\ncode](https://github.com/kachayev/fn.py/blob/master/fn/iters.py) and\r\nin [test\r\ncases](https://github.com/kachayev/fn.py/blob/master/tests.py).\r\n\r\nFunctional style for error-handling\r\n-----------------------------------\r\n\r\n-  Maybe\r\n-  Either\r\n\r\n**TODO: Implementation, code samples**\r\n\r\nTrampolines decorator\r\n---------------------\r\n\r\nWorkaround for dealing with TCO without heavy stack utilization.\r\n\r\n**TODO: Implementation, code samples and documented theory.**\r\n\r\nInstallation\r\n------------\r\n\r\nTo install ``fn.py``, simply:\r\n\r\n```console\r\n    $ pip install fn\r\n```\r\n\r\nOr, if you absolutely must:\r\n\r\n```console\r\n    $ easy_install fn\r\n```\r\n\r\nYou can also build library from source\r\n\r\n```console\r\n    $ git clone https://github.com/kachayev/fn.py.git\r\n    $ cd fn.py\r\n    $ python setup.py install\r\n```\r\n\r\nWork in progress (!)\r\n--------------------\r\n\r\n\"Roadmap\":\r\n\r\n-  Error handling (``Maybe``, ``Either`` from Haskell, ``Option`` from\r\n   Scala etc)\r\n-  Trampolines decorator\r\n-  Add to ``fn.iters`` module ``foldl``, ``foldr``, ``findelem``,\r\n   ``findindex``\r\n-  C-accelerator for most modules\r\n\r\nIdeas to think about:\r\n\r\n-  \"Pipeline\" notation for composition (back-order):\r\n   `F() >> list >> partial(map, int)`\r\n-  Curried function builder to simplify\r\n   ``lambda arg1: lambda arg2: ...``\r\n-  Scala-style for-yield loop to simplify long map/filter blocks\r\n\r\nContribute\r\n----------\r\n\r\n1. Check for open issues or open a fresh issue to start a discussion\r\n   around a feature idea or a bug.\r\n2. Fork the repository on Github to start making your changes to the\r\n   master branch (or branch off of it).\r\n3. Write a test which shows that the bug was fixed or that the feature\r\n   works as expected.","name":"Fn.py","tagline":"Functional programming in Python: implementation of missing features to enjoy FP"}